{"version":3,"file":"dap.umd.js","sources":["../node_modules/rollup-plugin-node-builtins/src/es6/events.js","../src/processor/enums.ts","../src/proxy/cmsis-dap.ts","../src/daplink/text-decoder.ts","../src/daplink/index.ts","../src/dap/adi.ts","../src/processor/cortex-m.ts","../src/transport/hid.ts","../node_modules/rollup-plugin-node-builtins/src/es6/os.js","../src/transport/usb.ts","../src/transport/webusb.ts"],"sourcesContent":["'use strict';\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nexport default EventEmitter;\nexport {EventEmitter};\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n/**\n * Processor Core States\n */\nexport const enum CoreState {\n    /**\n     * The core has been reset\n     */\n    RESET,\n    /**\n     * Core is running with a lockup condition\n     */\n    LOCKUP,\n    /**\n     * The core is sleeping\n     */\n    SLEEPING,\n    /**\n     * The core is in debug state\n     */\n    DEBUG,\n    /**\n     * The core is running\n     */\n    RUNNING\n}\n\n/**\n * Processor Core Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100230_0004_00_en/way1435345987733.html\n */\nexport const enum CoreRegister {\n    /**\n     * General purpose register\n     */\n    R0 = 0,\n    /**\n     * General purpose register\n     */\n    R1 = 1,\n    /**\n     * General purpose register\n     */\n    R2 = 2,\n    /**\n     * General purpose register\n     */\n    R3 = 3,\n    /**\n     * General purpose register\n     */\n    R4 = 4,\n    /**\n     * General purpose register\n     */\n    R5 = 5,\n    /**\n     * General purpose register\n     */\n    R6 = 6,\n    /**\n     * General purpose register\n     */\n    R7 = 7,\n    /**\n     * General purpose register\n     */\n    R8 = 8,\n    /**\n     * General purpose register\n     */\n    R9 = 9,\n    /**\n     * General purpose register\n     */\n    R10 = 10,\n    /**\n     * General purpose register\n     */\n    R11 = 11,\n    /**\n     * General purpose register\n     */\n    R12 = 12,\n    /**\n     * Stack Pointer\n     */\n    SP = 13,\n    /**\n     * The Link Register\n     */\n    LR = 14,\n    /**\n     * The Program Counter\n     */\n    PC = 15,\n    /**\n     * The Program Status Register\n     */\n    PSR = 16,\n    /**\n     * Main Stack Pointer\n     */\n    MSP = 17,\n    /**\n     * Process Stack Pointer\n     */\n    PSP = 18,\n    /**\n     * Prevents activation of exceptions\n     */\n    PRIMASK = 20,\n    /**\n     * Controls the stack used\n     */\n    CONTROL = 20\n}\n\n/**\n * Debug Registers\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.100165_0201_00_en/ric1417175947147.html\n */\nexport const enum DebugRegister {\n    /**\n     * Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30,\n    /**\n     * Debug Halting Control and Status Register\n     */\n    DHCSR = 0xE000EDF0,\n    /**\n     * Debug Core Register Selector Register, write only\n     */\n    DCRSR = 0xE000EDF4,\n    /**\n     * Debug Core Register Data Register\n     */\n    DCRDR = 0xE000EDF8,\n    /**\n     * Debug Exception and Monitor Control Register\n     */\n    DEMCR = 0xE000EDFC\n}\n\n/**\n * NVIC Registers\n */\nexport const enum NvicRegister {\n    /**\n     * NVIC: Interrupt Controller Type Register\n     */\n    ICT = 0xE000E004,\n    /**\n     * NVIC: CPUID Base Register\n     */\n    CPUID = 0xE000ED00,\n    /**\n     * NVIC: Application Interrupt/Reset Control Register\n     */\n    AIRCR = 0xE000ED0C,\n    /**\n     * NVIC: Debug Fault Status Register\n     */\n    DFSR = 0xE000ED30\n}\n\n/**\n * NVIC: Application Interrupt/Reset Control Register\n * @hidden\n */\nexport const enum AircrMask {\n    /**\n     * Reset Cortex-M (except Debug)\n     */\n    VECTRESET = (1 << 0),\n    /**\n     * Clear Active Vector Bit\n     */\n    VECTCLRACTIVE = (1 << 1),\n    /**\n     * Reset System (except Debug)\n     */\n    SYSRESETREQ = (1 << 2),\n    /**\n     * Write Key\n     */\n    VECTKEY = 0x05FA0000\n}\n\n/**\n * Debug Halting Control and Status Register\n * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337e/CEGCJAHJ.html\n * @hidden\n */\nexport const enum DhcsrMask {\n    /**\n     * Enables debug\n     */\n    C_DEBUGEN = (1 << 0),\n    /**\n     * Halts the core\n     */\n    C_HALT = (1 << 1),\n    /**\n     * Steps the core in halted debug\n     */\n    C_STEP = (1 << 2),\n    /**\n     * Mask interrupts when stepping or running in halted debug\n     */\n    C_MASKINTS = (1 << 3),\n    /**\n     * Enables Halting debug to gain control\n     */\n    C_SNAPSTALL = (1 << 5),\n    /**\n     * Register Read/Write on the Debug Core Register Selector register is available\n     */\n    S_REGRDY = (1 << 16),\n    /**\n     * The core is in debug state\n     */\n    S_HALT = (1 << 17),\n    /**\n     * Indicates that the core is sleeping\n     */\n    S_SLEEP = (1 << 18),\n    /**\n     * Core is running (not halted) and a lockup condition is present\n     */\n    S_LOCKUP = (1 << 19),\n    /**\n     * An instruction has completed since last read\n     */\n    S_RETIRE_ST = (1 << 24),\n    /**\n     * The core has been reset\n     */\n    S_RESET_ST = (1 << 25),\n    /**\n     * Debug Key\n     */\n    DBGKEY = (0xA05F << 16)\n}\n\n/**\n * Debug Fault Status Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0413d/Cihdifbf.html\n * @hidden\n */\nexport const enum DfsrMask {\n    /**\n     * Halt request flag\n     */\n    HALTED = (1 << 0),\n    /**\n     * BKPT instruction or hardware breakpoint match\n     */\n    BKPT = (1 << 1),\n    /**\n     * Data Watchpoint (DW) flag\n     */\n    DWTTRAP = (1 << 2),\n    /**\n     * Vector catch occurred\n     */\n    VCATCH = (1 << 3),\n    /**\n     * External debug request (EDBGRQ) has halted the core\n     */\n    EXTERNAL = (1 << 4)\n}\n\n/**\n * Debug Core Register Selector Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGIAJBH.html\n * @hidden\n */\nexport const enum DcrsrMask {\n    /**\n     * Register write or read, write is 1\n     */\n    REGWnR = (1 << 16),\n    /**\n     * Register select - DebugReturnAddress & PSR/Flags, Execution Number, and state information\n     */\n    REGSEL = 0x1F,\n}\n\n/**\n * Debug Exception and Monitor Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/CEGHJDCF.html\n * @hidden\n */\nexport const enum DemcrMask {\n    /**\n     * Reset Vector Catch\n     */\n    CORERESET = (1 << 0),\n    /**\n     * Debug Trap on MMU Fault\n     */\n    MMERR = (1 << 4),\n    /**\n     * Debug Trap on No Coprocessor Fault\n     */\n    NOCPERR = (1 << 5),\n    /**\n     * Debug Trap on Checking Error Fault\n     */\n    CHKERR = (1 << 6),\n    /**\n     * Debug Trap on State Error Fault\n     */\n    STATERR = (1 << 7),\n    /**\n     * Debug Trap on Bus Error Fault\n     */\n    BUSERR = (1 << 8),\n    /**\n     * Debug Trap on Interrupt Error Fault\n     */\n    INTERR = (1 << 9),\n    /**\n     * Debug Trap on Hard Fault\n     */\n    HARDERR = (1 << 10),\n    /**\n     * Monitor Enable\n     */\n    MON_EN = (1 << 16),\n    /**\n     * Monitor Pend\n     */\n    MON_PEND = (1 << 17),\n    /**\n     * Monitor Step\n     */\n    MON_STEP = (1 << 18),\n    /**\n     * Monitor Request\n     */\n    MON_REQ = (1 << 19),\n    /**\n     * Trace Enable\n     */\n    TRCENA = (1 << 24)\n}\n\n/**\n * Flash Patch and Breakpoint Registers\n * http://infocenter.arm.com/help/topic/com.arm.doc.100165_0201_00_en/ric1417175949176.html\n * @hidden\n */\nexport const enum FPBRegister {\n    /**\n     * FlashPatch Control Register\n     */\n    FP_CTRL = 0xE0002000,\n    /**\n     * FlashPatch Remap Register\n     */\n    FP_REMAP = 0xE0002004,\n    /**\n     * FlashPatch Comparator Register0\n     */\n    FP_COMP0 = 0xE0002008,\n    /**\n     * FlashPatch Comparator Register1\n     */\n    FP_COMP1 = 0xE000200C,\n    /**\n     * FlashPatch Comparator Register2\n     */\n    FP_COMP2 = 0xE0002010,\n    /**\n     * FlashPatch Comparator Register3\n     */\n    FP_COMP3 = 0xE0002014,\n    /**\n     * FlashPatch Comparator Register4\n     */\n    FP_COMP4 = 0xE0002018,\n    /**\n     * FlashPatch Comparator Register5\n     */\n    FP_COMP5 = 0xE000201C,\n    /**\n     * FlashPatch Comparator Register6\n     */\n    FP_COMP6 = 0xE0002020,\n    /**\n     * FlashPatch Comparator Register7\n     */\n    FP_COMP7 = 0xE0002024,\n}\n\n/**\n * Flash Patch and Breakpoint Control Register Mask\n * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/ch11s04s01.html#BABCAFAG\n * @hidden\n */\nexport enum FPBCtrlMask {\n    /**\n     * Flash patch unit enable\n     */\n    ENABLE = (1 << 0),\n    /**\n     * Key field which enables writing to the Flash Patch Control Register\n     */\n    KEY = (1 << 1)\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { EventEmitter } from 'events';\nimport { Transport } from '../transport';\nimport {\n    DAPPort,\n    DAPTransferMode,\n    DAPProtocol,\n    DAPCommand,\n    DAPConnectResponse,\n    DAPResponse,\n    DAPInfoRequest,\n    DAPResetTargeResponse,\n    DAPTransferResponse\n} from './enums';\nimport { Proxy, DAPOperation } from './';\nimport { AbortMask } from '..';\n\n/**\n * @hidden\n */\nexport const DEFAULT_CLOCK_FREQUENCY = 10000000;\n/**\n * @hidden\n */\nconst SWD_SEQUENCE = 0xE79E;\n/**\n * @hidden\n */\nconst JTAG_SEQUENCE = 0xE73C;\n\n/**\n * @hidden\n */\nconst BLOCK_HEADER_SIZE = 4;\n/**\n * @hidden\n */\nconst TRANSFER_HEADER_SIZE = 2;\n/**\n * @hidden\n */\nconst TRANSFER_OPERATION_SIZE = 5;\n\n/**\n * @hidden\n */\nclass Mutex {\n    private locked = false;\n\n    /**\n     * Wait until the Mutex is available and claim it\n     */\n    public async lock(): Promise<void> {\n        while (this.locked) {\n            // Yield the current execution context, effectively moving it to the back of the promise queue\n            await new Promise(resolve => setTimeout(resolve, 1));\n        }\n        this.locked = true;\n    }\n\n    /**\n     * Unlock the Mutex\n     */\n    public unlock(): void {\n        this.locked = false;\n    }\n}\n\n/**\n * CMSIS-DAP class\n * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__Commands__gr.html\n */\nexport class CmsisDAP extends EventEmitter implements Proxy {\n\n    /**\n     * Whether the device has been opened\n     */\n    public connected = false;\n\n    /**\n     * The maximum DAPOperations which can be transferred\n     */\n    public operationCount: number;\n\n    /**\n     * The maximum block size which can be transferred\n     */\n    public blockSize: number;\n\n    private sendMutex = new Mutex();\n\n    /**\n     * CMSIS-DAP constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(private transport: Transport, private mode: DAPProtocol = DAPProtocol.DEFAULT, private clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super();\n\n        // Determine the block size\n        this.blockSize = this.transport.packetSize - BLOCK_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER_BLOCK command\n\n        // Determine the operation count possible\n        const operationSpace = this.transport.packetSize - TRANSFER_HEADER_SIZE - 1; // -1 for the DAP_TRANSFER command\n        this.operationCount = Math.floor(operationSpace / TRANSFER_OPERATION_SIZE);\n    }\n\n    private bufferSourceToUint8Array(prefix: number, data?: BufferSource): Uint8Array {\n\n        if (!data) {\n            return new Uint8Array([prefix]);\n        }\n\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const result = new Uint8Array(arrayBuffer.byteLength + 1);\n\n        result.set([prefix]);\n        result.set(new Uint8Array(arrayBuffer), 1);\n\n        return result;\n    }\n\n    /**\n     * Switches the CMSIS-DAP unit to use SWD\n     * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0316d/Chdhfbhc.html\n     */\n    protected async selectProtocol(protocol: DAPProtocol): Promise<void> {\n        const sequence = protocol === DAPProtocol.JTAG ? JTAG_SEQUENCE : SWD_SEQUENCE;\n\n        await this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])); // Sequence of 1's\n        await this.swjSequence(new Uint16Array([sequence]));                                // Send protocol sequence\n        await this.swjSequence(new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])); // Sequence of 1's\n        await this.swjSequence(new Uint8Array([0x00]));\n    }\n\n    /**\n     * Send a command\n     * @param command Command to send\n     * @param data Data to use\n     * @returns Promise of DataView\n     */\n    protected async send(command: number, data?: BufferSource): Promise<DataView> {\n        const array = this.bufferSourceToUint8Array(command, data);\n        await this.sendMutex.lock();\n\n        try {\n            await this.transport.write(array);\n            const response = await this.transport.read();\n\n            if (response.getUint8(0) !== command) {\n                throw new Error(`Bad response for ${command} -> ${response.getUint8(0)}`);\n            }\n\n            switch (command) {\n                case DAPCommand.DAP_DISCONNECT:\n                case DAPCommand.DAP_WRITE_ABORT:\n                case DAPCommand.DAP_DELAY:\n                case DAPCommand.DAP_RESET_TARGET:\n                case DAPCommand.DAP_SWJ_CLOCK:\n                case DAPCommand.DAP_SWJ_SEQUENCE:\n                case DAPCommand.DAP_SWD_CONFIGURE:\n                case DAPCommand.DAP_SWD_SEQUENCE:\n                case DAPCommand.DAP_SWO_TRANSPORT:\n                case DAPCommand.DAP_SWO_MODE:\n                case DAPCommand.DAP_SWO_CONTROL:\n                case DAPCommand.DAP_JTAG_CONFIGURE:\n                case DAPCommand.DAP_JTAG_ID_CODE:\n                case DAPCommand.DAP_TRANSFER_CONFIGURE:\n                    if (response.getUint8(1) !== DAPResponse.DAP_OK) {\n                        throw new Error(`Bad status for ${command} -> ${response.getUint8(1)}`);\n                    }\n            }\n\n            return response;\n        } finally {\n            this.sendMutex.unlock();\n        }\n    }\n\n    /**\n     * Clears the abort register of all error flags\n     * @param abortMask Optional AbortMask to use, otherwise clears all flags\n     */\n    protected async clearAbort(abortMask: number = AbortMask.WDERRCLR | AbortMask.STKERRCLR | AbortMask.STKCMPCLR | AbortMask.ORUNERRCLR): Promise<void> {\n        await this.send(DAPCommand.DAP_WRITE_ABORT, new Uint8Array([0, abortMask]));\n    }\n\n    /**\n     * Get DAP information\n     * @param request Type of information to get\n     * @returns Promise of number or string\n     */\n    public async dapInfo(request: DAPInfoRequest): Promise<number | string> {\n        try {\n            const result = await this.send(DAPCommand.DAP_INFO, new Uint8Array([request]));\n            const length = result.getUint8(1);\n\n            if (length === 0) {\n                throw new Error('DAP Info Failure');\n            }\n\n            switch (request) {\n                case DAPInfoRequest.CAPABILITIES:\n                case DAPInfoRequest.PACKET_COUNT:\n                case DAPInfoRequest.PACKET_SIZE:\n                case DAPInfoRequest.SWO_TRACE_BUFFER_SIZE:\n                    // Byte\n                    if (length === 1) return result.getUint8(2);\n\n                    // Short\n                    if (length === 2) return result.getUint16(2);\n\n                    // Word\n                    if (length === 4) return result.getUint32(2);\n            }\n\n            const ascii = Array.prototype.slice.call(new Uint8Array(result.buffer, 2, length));\n            return String.fromCharCode.apply(null, ascii);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Send an SWJ Sequence\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__SWJ__Sequence.html\n     * @param sequence The sequence to send\n     * @returns Promise\n     */\n    public async swjSequence(sequence: BufferSource): Promise<void> {\n        const bitLength = sequence.byteLength * 8;\n        const data = this.bufferSourceToUint8Array(bitLength, sequence);\n\n        try {\n            await this.send(DAPCommand.DAP_SWJ_SEQUENCE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Configure Transfer\n     * https://www.keil.com/pack/doc/CMSIS/DAP/html/group__DAP__TransferConfigure.html\n     * @param idleCycles Number of extra idle cycles after each transfer\n     * @param waitRetry Number of transfer retries after WAIT response\n     * @param matchRetry Number of retries on reads with Value Match in DAP_Transfer\n     * @returns Promise\n     */\n    public async configureTransfer(idleCycles: number, waitRetry: number, matchRetry: number): Promise<void> {\n        const data = new Uint8Array(5);\n        const view = new DataView(data.buffer);\n\n        view.setUint8(0, idleCycles);\n        view.setUint16(1, waitRetry, true);\n        view.setUint16(3, matchRetry, true);\n\n        try {\n            await this.send(DAPCommand.DAP_TRANSFER_CONFIGURE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public async connect(): Promise<void> {\n        if (this.connected === true) {\n            return;\n        }\n\n        await this.transport.open();\n\n        try {\n            await this.send(DAPCommand.DAP_SWJ_CLOCK, new Uint32Array([this.clockFrequency]));\n            const result = await this.send(DAPCommand.DAP_CONNECT, new Uint8Array([this.mode]));\n\n            if (result.getUint8(1) === DAPConnectResponse.FAILED || this.mode !== DAPProtocol.DEFAULT && result.getUint8(1) !== this.mode) {\n                throw new Error('Mode not enabled.');\n            }\n        } catch (error) {\n            await this.clearAbort();\n            await this.transport.close();\n            throw error;\n        }\n\n        try {\n            await this.configureTransfer(0, 100, 0);\n            await this.selectProtocol(DAPProtocol.SWD);\n        } catch (error) {\n            await this.transport.close();\n            throw error;\n        }\n\n        this.connected = true;\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public async disconnect(): Promise<void> {\n        if (this.connected === false) {\n            return;\n        }\n\n        try {\n            await this.send(DAPCommand.DAP_DISCONNECT);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        await this.transport.close();\n        this.connected = false;\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public async reconnect(): Promise<void> {\n        await this.disconnect();\n        await new Promise(resolve => setTimeout(resolve, 100));\n        await this.connect();\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise of whether a device specific reset sequence is implemented\n     */\n    public async reset(): Promise<boolean> {\n        try {\n            const response = await this.send(DAPCommand.DAP_RESET_TARGET);\n            return response.getUint8(2) === DAPResetTargeResponse.RESET_SEQUENCE;\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Transfer data with a single read or write operation\n     * @param port Port type (debug port or access port)\n     * @param mode Whether to read or write\n     * @param register The register to use\n     * @param value Any value to write\n     * @returns Promise of any value read\n     */\n    public transfer(port: DAPPort, mode: DAPTransferMode, register: number, value?: number): Promise<number>;\n    /**\n     * Transfer data with multiple read or write operations\n     * @param operations The operations to use\n     * @returns Promise of any values read\n     */\n    public transfer(operations: DAPOperation[]): Promise<Uint32Array>;\n    public async transfer(portOrOps: DAPPort | DAPOperation[], mode: DAPTransferMode = DAPTransferMode.READ, register: number = 0, value: number = 0): Promise<number | Uint32Array> {\n\n        let operations: DAPOperation[];\n\n        if (typeof portOrOps === 'number') {\n            operations = [{\n                port: portOrOps,\n                mode,\n                register,\n                value\n            }];\n        } else {\n            operations = portOrOps;\n        }\n\n        const data = new Uint8Array(TRANSFER_HEADER_SIZE + (operations.length * TRANSFER_OPERATION_SIZE));\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint8(1, operations.length);\n\n        operations.forEach((operation, index) => {\n            const offset = TRANSFER_HEADER_SIZE + (index * TRANSFER_OPERATION_SIZE);\n\n            // Transfer request\n            view.setUint8(offset, operation.port | operation.mode | operation.register);\n            // Transfer data\n            view.setUint32(offset + 1, operation.value || 0, true);\n        });\n\n        try {\n            const result = await this.send(DAPCommand.DAP_TRANSFER, data);\n\n            // Transfer count\n            if (result.getUint8(1) !== operations.length) {\n                throw new Error('Transfer count mismatch');\n            }\n\n            // Transfer response\n            const response = result.getUint8(2);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error('Transfer response WAIT');\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error('Transfer response FAULT');\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error('Transfer response PROTOCOL_ERROR');\n            }\n            if (response === DAPTransferResponse.VALUE_MISMATCH) {\n                throw new Error('Transfer response VALUE_MISMATCH');\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error('Transfer response NO_ACK');\n            }\n\n            if (typeof portOrOps === 'number') {\n                return result.getUint32(3, true);\n            }\n\n            const length = operations.length * 4;\n            return new Uint32Array(result.buffer.slice(3, 3 + length));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read a block of data from a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @returns Promise of values read\n     */\n    public transferBlock(port: DAPPort, register: number, count: number): Promise<Uint32Array>;\n    /**\n     * Write a block of data to a single register\n     * @param port Port type (debug port or access port)\n     * @param register The register to use\n     * @param values The values to write\n     * @returns Promise\n     */\n    public transferBlock(port: DAPPort, register: number, values: Uint32Array): Promise<undefined>;\n    public async transferBlock(port: DAPPort, register: number, countOrValues: number | Uint32Array): Promise<Uint32Array | undefined> {\n\n        let operationCount: number;\n        let mode: DAPTransferMode;\n        let dataSize = BLOCK_HEADER_SIZE;\n\n        if (typeof countOrValues === 'number') {\n            operationCount = countOrValues;\n            mode = DAPTransferMode.READ;\n        } else {\n            operationCount = countOrValues.length;\n            mode = DAPTransferMode.WRITE;\n            dataSize += countOrValues.byteLength;\n        }\n\n        const data = new Uint8Array(dataSize);\n        const view = new DataView(data.buffer);\n\n        // DAP Index, ignored for SWD\n        view.setUint8(0, 0);\n        // Transfer count\n        view.setUint16(1, operationCount, true);\n        // Transfer request\n        view.setUint8(3, port | mode | register);\n\n        if (typeof countOrValues !== 'number') {\n            // Transfer data\n            countOrValues.forEach((countOrValue, index) => {\n                const offset = BLOCK_HEADER_SIZE + (index * 4);\n                // Transfer data\n                view.setUint32(offset, countOrValue, true);\n            });\n        }\n\n        try {\n            const result = await this.send(DAPCommand.DAP_TRANSFER_BLOCK, view);\n\n            // Transfer count\n            if (result.getUint16(1, true) !== operationCount) {\n                throw new Error('Transfer count mismatch');\n            }\n\n            // Transfer response\n            const response = result.getUint8(3);\n            if (response === DAPTransferResponse.WAIT) {\n                throw new Error('Transfer response WAIT');\n            }\n            if (response === DAPTransferResponse.FAULT) {\n                throw new Error('Transfer response FAULT');\n            }\n            if (response === DAPTransferResponse.PROTOCOL_ERROR) {\n                throw new Error('Transfer response PROTOCOL_ERROR');\n            }\n            if (response === DAPTransferResponse.NO_ACK) {\n                throw new Error('Transfer response NO_ACK');\n            }\n\n            if (typeof countOrValues === 'number') {\n                return new Uint32Array(result.buffer.slice(4, 4 + operationCount * 4));\n            }\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        return undefined;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2020\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n// https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n\nconst PARTIAL_CHAR_TEST = /[\\xc0-\\xff][\\x80-\\xbf]*$/g;\nconst DOUBLE_BYTE_REPLACE = /[\\xc0-\\xff][\\x80-\\xbf]*/g;\n\nexport class TextDecoder {\n\n    private partialChar: string | undefined;\n\n    /**\n     * Decode an ArrayBuffer to a string, handling double-byte characters\n     * @param input The ArrayBuffer to decode\n     */\n    public decode(input: ArrayBuffer): string {\n\n        const numberArray = Array.prototype.slice.call(new Uint8Array(input));\n        let data = String.fromCodePoint.apply(undefined, numberArray);\n\n        if (this.partialChar) {\n            // Previous double-byte character was cut off\n            data = `${this.partialChar}${data}`;\n            this.partialChar = undefined;\n        }\n\n        const match = data.match(PARTIAL_CHAR_TEST);\n        if (match) {\n            // Partial double-byte character at end of string, save it and truncate data\n            const length = match[0].length;\n            this.partialChar = data.slice(-length);\n            data = data.slice(0, -length);\n        }\n\n        return data.replace(DOUBLE_BYTE_REPLACE, this.decoderReplacer);\n    }\n\n    private decoderReplacer(encoded: string): string {\n        let codePoint = encoded.codePointAt(0)! << 24;\n        const leadingOnes = Math.clz32(~codePoint);\n        let endPos = 0;\n        const stringLen = encoded.length;\n        let result = '';\n        if (leadingOnes < 5 && stringLen >= leadingOnes) {\n            codePoint = (codePoint << leadingOnes) >>> (24 + leadingOnes);\n            for (endPos = 1; endPos < leadingOnes; endPos = endPos + 1) {\n                codePoint = (codePoint << 6) | (encoded.codePointAt(endPos)! & 0x3f);\n            }\n            if (codePoint <= 0xFFFF) { // BMP code point\n                result += String.fromCodePoint(codePoint);\n            } else if (codePoint <= 0x10FFFF) {\n                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint = codePoint - 0x10000;\n                result += String.fromCodePoint(\n                    (codePoint >> 10) + 0xD800,  // highSurrogate\n                    (codePoint & 0x3ff) + 0xDC00 // lowSurrogate\n                );\n            } else endPos = 0; // to fill it in with INVALIDs\n        }\n        for (; endPos < stringLen; endPos = endPos + 1) {\n            result += '\\ufffd'; // replacement character\n        }\n        return result;\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { TextDecoder } from './text-decoder';\nimport { CmsisDAP, DAPProtocol, DEFAULT_CLOCK_FREQUENCY } from '../proxy';\nimport { Transport } from '../transport';\nimport { DAPLinkFlash, DAPLinkSerial } from './enums';\n\n/**\n * @hidden\n */\nconst DEFAULT_BAUDRATE = 9600;\n/**\n * @hidden\n */\nconst DEFAULT_SERIAL_DELAY = 100;\n/**\n * @hidden\n */\nconst DEFAULT_PAGE_SIZE = 62;\n\n/**\n * @hidden\n */\nconst decoder = new TextDecoder();\n\n/**\n * DAPLink Class\n */\nexport class DAPLink extends CmsisDAP {\n\n    /**\n     * Progress event\n     * @event\n     */\n    public static EVENT_PROGRESS: string = 'progress';\n\n    /**\n     * Serial read event\n     * @event\n     */\n    public static EVENT_SERIAL_DATA: string = 'serial';\n\n    /**\n     * @hidden\n     */\n    protected serialPolling = false;\n\n    /**\n     * @hidden\n     */\n    protected serialListeners = false;\n\n    /**\n     * DAPLink constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super(transport, mode, clockFrequency);\n\n        this.on('newListener', async event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = true;\n                }\n            }\n        });\n\n        this.on('removeListener', event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = false;\n                }\n            }\n        });\n    }\n\n    /**\n     * Detect if buffer contains text or binary data\n     */\n    private isBufferBinary(buffer: ArrayBuffer): boolean {\n        const numberArray = Array.prototype.slice.call(new Uint16Array(buffer, 0, 50));\n        const bufferString: string = String.fromCharCode.apply(null, numberArray);\n\n        for (let i = 0; i < bufferString.length; i++) {\n            const charCode = bufferString.charCodeAt(i);\n            // 65533 is a code for unknown character\n            // 0-8 are codes for control characters\n            if (charCode === 65533 || charCode <= 8) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private async writeBuffer(buffer: ArrayBuffer, pageSize: number, offset: number = 0): Promise<void> {\n        const end = Math.min(buffer.byteLength, offset + pageSize);\n        const page = buffer.slice(offset, end);\n        const data = new Uint8Array(page.byteLength + 1);\n\n        data.set([page.byteLength]);\n        data.set(new Uint8Array(page), 1);\n\n        try {\n            await this.send(DAPLinkFlash.WRITE, data);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n\n        this.emit(DAPLink.EVENT_PROGRESS, offset / buffer.byteLength);\n        if (end < buffer.byteLength) {\n            return this.writeBuffer(buffer, pageSize, end);\n        }\n    }\n\n    /**\n     * Flash the target\n     * @param buffer The image to flash\n     * @param pageSize The page size to use (defaults to 62)\n     * @returns Promise\n     */\n    public async flash(buffer: BufferSource, pageSize: number = DEFAULT_PAGE_SIZE): Promise<void> {\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(buffer) ? buffer.buffer : buffer;\n        const streamType = this.isBufferBinary(arrayBuffer) ? 0 : 1;\n\n        try {\n            let result = await this.send(DAPLinkFlash.OPEN, new Uint32Array([streamType]));\n\n            // An error occurred\n            if (result.getUint8(1) !== 0) {\n                throw new Error('Flash error');\n            }\n\n            await this.writeBuffer(arrayBuffer, pageSize);\n            this.emit(DAPLink.EVENT_PROGRESS, 1.0);\n            result = await this.send(DAPLinkFlash.CLOSE);\n\n            // An error occurred\n            if (result.getUint8(1) !== 0) {\n                throw new Error('Flash error');\n            }\n\n            await this.send(DAPLinkFlash.RESET);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Get the serial baud rate setting\n     * @returns Promise of baud rate\n     */\n    public async getSerialBaudrate(): Promise<number> {\n        try {\n            const result = await this.send(DAPLinkSerial.READ_SETTINGS);\n            return result.getUint32(1, true);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Set the serial baud rate setting\n     * @param baudrate The baudrate to use (defaults to 9600)\n     * @returns Promise\n     */\n    public async setSerialBaudrate(baudrate: number = DEFAULT_BAUDRATE): Promise<void> {\n        try {\n            await this.send(DAPLinkSerial.WRITE_SETTINGS, new Uint32Array([baudrate]));\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Write serial data\n     * @param data The data to write\n     * @returns Promise\n     */\n    public async serialWrite(data: string): Promise<void> {\n        const arrayData = data.split('').map((e: string) => e.charCodeAt(0));\n        arrayData.unshift(arrayData.length);\n        try {\n            await this.send(DAPLinkSerial.WRITE, new Uint8Array(arrayData).buffer);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Read serial data\n     * @returns Promise of any arrayBuffer read\n     */\n    public async serialRead(): Promise<ArrayBuffer | undefined> {\n        try {\n            const serialData = await this.send(DAPLinkSerial.READ);\n            // Check if there is any data returned from the device\n            if (serialData.byteLength === 0) {\n                return undefined;\n            }\n\n            // First byte contains the vendor code\n            if (serialData.getUint8(0) !== DAPLinkSerial.READ) {\n                return undefined;\n            }\n\n            // Second byte contains the actual length of data read from the device\n            const dataLength = serialData.getUint8(1);\n            if (dataLength === 0) {\n                return undefined;\n            }\n\n            const offset = 2;\n            return serialData.buffer.slice(offset, offset + dataLength);\n        } catch (error) {\n            await this.clearAbort();\n            throw error;\n        }\n    }\n\n    /**\n     * Start listening for serial data\n     * @param serialDelay The serial delay to use (default 100)\n     * @param autoConnect whether to automatically connect to the target (default true)\n     */\n    public async startSerialRead(serialDelay: number = DEFAULT_SERIAL_DELAY, autoConnect = true) {\n        this.serialPolling = true;\n\n        while (this.serialPolling) {\n\n            // Don't read serial output unless we have event listeners\n            if (this.serialListeners) {\n\n                // Remember connection state\n                const connectedState = this.connected;\n\n                if (this.connected === false && autoConnect === true) {\n                    await this.connect();\n                }\n\n                const serialData = await this.serialRead();\n\n                // Put state back\n                if (connectedState === false && autoConnect === true) {\n                    await this.disconnect();\n                }\n\n                if (serialData !== undefined) {\n                    const data = decoder.decode(serialData);\n                    this.emit(DAPLink.EVENT_SERIAL_DATA, data);\n                }\n            }\n\n            await new Promise(resolve => setTimeout(resolve, serialDelay));\n        }\n    }\n\n    /**\n     * Stop listening for serial data\n     */\n    public stopSerialRead() {\n        this.serialPolling = false;\n    }\n}\n\nexport * from './enums';\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from '../transport';\nimport { Proxy, CmsisDAP, DAPOperation } from '../proxy';\nimport { DPRegister, APRegister, CSWMask, BankSelectMask, AbortMask, CtrlStatMask } from './enums';\nimport { DAP } from './';\nimport { DAPTransferMode, DAPPort, DAPProtocol } from '../proxy/enums';\nimport { DEFAULT_CLOCK_FREQUENCY } from '../proxy/cmsis-dap';\n\n/**\n * @hidden\n */\nconst DEFAULT_WAIT_DELAY = 100;\n\n/**\n * Arm Debug Interface class\n */\nexport class ADI implements DAP {\n\n    private selectedAddress?: number;\n    private cswValue?: number;\n    private proxy: Proxy;\n\n    /**\n     * ADI constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use (default 0)\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode?: DAPProtocol, clockFrequency?: number);\n    /**\n     * ADI constructor\n     * @param proxy Proxy to use\n     */\n    constructor(proxy: Proxy);\n    constructor(transportOrDap: Transport | Proxy, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        const isTransport = (test: Transport | Proxy): test is Transport => {\n            return (test as Transport).open !== undefined;\n        };\n\n        this.proxy = isTransport(transportOrDap) ? new CmsisDAP(transportOrDap, mode, clockFrequency) : transportOrDap;\n    }\n\n    /**\n     * Continually run a function until it returns true\n     * @param fn The function to run\n     * @param timeout Optional timeout to wait before giving up and throwing\n     * @param timer The milliseconds to wait between each run\n     * @returns Promise\n     */\n    protected async waitDelay(fn: () => Promise<boolean>, timeout: number = 0, timer: number = DEFAULT_WAIT_DELAY): Promise<void> {\n        let running = true;\n\n        if (timeout > 0) {\n            setTimeout(() => {\n                if (running) {\n                    running = false;\n                    throw new Error('Wait timed out');\n                }\n            }, timeout);\n        }\n\n        while (running) {\n            const result = await fn();\n            if (result === true) {\n                running = false;\n                return;\n            }\n\n            if (timer > 0) {\n                await new Promise(resolve => setTimeout(resolve, timeout));\n            }\n        }\n    }\n\n    protected concatTypedArray(arrays: Uint32Array[]): Uint32Array {\n        // Only one array exists\n        if (arrays.length === 1) return arrays[0];\n\n        // Determine array length\n        let length: number = 0;\n        for (const array of arrays) {\n            length += array.length;\n        }\n\n        // Concat the arrays\n        const result = new Uint32Array(length);\n        for (let i = 0, j = 0; i < arrays.length; i++) {\n            result.set(arrays[i], j);\n            j += arrays[i].length;\n        }\n\n        return result;\n    }\n\n    protected readDPCommand(register: number): DAPOperation[] {\n        return [{\n            mode: DAPTransferMode.READ,\n            port: DAPPort.DEBUG,\n            register\n        }];\n    }\n\n    protected writeDPCommand(register: number, value: number): DAPOperation[] {\n        if (register === DPRegister.SELECT) {\n            if (value === this.selectedAddress) {\n                return [];\n            }\n            this.selectedAddress = value;\n        }\n\n        return [{\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.DEBUG,\n            register,\n            value\n        }];\n    }\n\n    protected readAPCommand(register: number): DAPOperation[] {\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.READ,\n            port: DAPPort.ACCESS,\n            register\n        });\n    }\n\n    protected writeAPCommand(register: number, value: number): DAPOperation[] {\n        if (register === APRegister.CSW) {\n            if (value === this.cswValue) {\n                return [];\n            }\n            this.cswValue = value;\n        }\n\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.ACCESS,\n            register,\n            value\n        });\n    }\n\n    protected readMem16Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem16Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem32Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem32Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.writeAPCommand(APRegister.DRW, value as number));\n    }\n\n    protected async transferSequence(operations: DAPOperation[][]): Promise<Uint32Array> {\n        // Flatten operations into single array\n        let merged: DAPOperation[] = [];\n        merged = merged.concat(...operations);\n\n        const results: Uint32Array[] = [];\n\n        // Split operations into sequences no longer than operation count\n        while (merged.length) {\n            const sequence = merged.splice(0, this.proxy.operationCount);\n            const result = await this.proxy.transfer(sequence);\n            results.push(result);\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public async connect() {\n        const mask = CtrlStatMask.CDBGPWRUPACK | CtrlStatMask.CSYSPWRUPACK;\n\n        await this.proxy.connect();\n        await this.readDP(DPRegister.DPIDR);\n        await this.transferSequence([\n            this.writeDPCommand(DPRegister.ABORT, AbortMask.STKERRCLR), // clear sticky error\n            this.writeDPCommand(DPRegister.SELECT, APRegister.CSW), // select CTRL_STAT\n            this.writeDPCommand(DPRegister.CTRL_STAT, CtrlStatMask.CSYSPWRUPREQ | CtrlStatMask.CDBGPWRUPREQ)\n        ]);\n\n        // Wait until system and debug have powered up\n        await this.waitDelay(async () => {\n            const status = await this.readDP(DPRegister.CTRL_STAT);\n            return (status & mask) === mask;\n        });\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public disconnect(): Promise<void> {\n        return this.proxy.disconnect();\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public async reconnect(): Promise<void> {\n        await this.disconnect();\n        await new Promise(resolve => setTimeout(resolve, DEFAULT_WAIT_DELAY));\n        await this.connect();\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise\n     */\n    public reset(): Promise<boolean> {\n        return this.proxy.reset();\n    }\n\n    /**\n     * Read from a debug port register\n     * @param register DP register to read\n     * @returns Promise of register value\n     */\n    public async readDP(register: DPRegister): Promise<number> {\n        const result = await this.proxy.transfer(this.readDPCommand(register));\n        return result[0];\n    }\n\n    /**\n     * Write to a debug port register\n     * @param register DP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public async writeDP(register: DPRegister, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeDPCommand(register, value));\n    }\n\n    /**\n     * Read from an access port register\n     * @param register AP register to read\n     * @returns Promise of register value\n     */\n    public async readAP(register: APRegister): Promise<number> {\n        const result = await this.proxy.transfer(this.readAPCommand(register));\n        return result[0];\n    }\n\n    /**\n     * Write to an access port register\n     * @param register AP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public async writeAP(register: APRegister, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeAPCommand(register, value));\n    }\n\n    /**\n     * Read a 16-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem16(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem16Command(register));\n        return result[0];\n    }\n\n    /**\n     * Write a 16-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem16(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x02) << 3);\n        await this.proxy.transfer(this.writeMem16Command(register, value));\n    }\n\n    /**\n     * Read a 32-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public async readMem32(register: number): Promise<number> {\n        const result = await this.proxy.transfer(this.readMem32Command(register));\n        return result[0];\n    }\n\n    /**\n     * Write a 32-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeMem32(register: number, value: number): Promise<void> {\n        await this.proxy.transfer(this.writeMem32Command(register, value));\n    }\n\n    /**\n     * Read a block of 32-bit words from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public async readBlock(register: number, count: number): Promise<Uint32Array> {\n        await this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register),\n        ]);\n\n        const results: Uint32Array[] = [];\n\n        // Split into requests no longer than block size\n        let remainder = count;\n        while (remainder > 0) {\n            const chunkSize = Math.min(remainder, Math.floor(this.proxy.blockSize / 4));\n            const result = await this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunkSize);\n            results.push(result);\n            remainder -= chunkSize;\n        }\n\n        return this.concatTypedArray(results);\n    }\n\n    /**\n     * Write a block of 32-bit words to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public async writeBlock(register: number, values: Uint32Array): Promise<void> {\n        await this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register),\n        ]);\n\n        // Split values into chunks no longer than block size\n        let index = 0;\n        while (index < values.length) {\n            const chunk = values.slice(index, index + Math.floor(this.proxy.blockSize / 4));\n            await this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunk);\n            index += Math.floor(this.proxy.blockSize / 4);\n        }\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { ADI } from '../dap';\nimport {\n    DebugRegister,\n    CoreRegister,\n    DhcsrMask,\n    DfsrMask,\n    DcrsrMask,\n    CoreState,\n    NvicRegister,\n    AircrMask,\n    DemcrMask\n} from './enums';\nimport { Processor } from './';\nimport { DAPOperation } from '../proxy';\n\n/**\n * @hidden\n */\nconst EXECUTE_TIMEOUT = 10000;\n/**\n * @hidden\n */\nconst BKPT_INSTRUCTION = 0xBE2A;\n/**\n * @hidden\n */\nconst GENERAL_REGISTER_COUNT = 12;\n\n/**\n * Cortex M class\n */\nexport class CortexM extends ADI implements Processor {\n\n    private enableDebug() {\n        return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN);\n    }\n\n    protected readCoreRegisterCommand(register: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRSR, register)\n        .concat(this.readMem32Command(DebugRegister.DHCSR))\n        .concat(this.readMem32Command(DebugRegister.DCRDR));\n    }\n\n    protected writeCoreRegisterCommand(register: number, value: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRDR, value)\n        .concat(this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR));\n    }\n\n    /**\n     * Get the state of the processor core\n     * @returns Promise of CoreState\n     */\n    public async getState(): Promise<CoreState> {\n        const dhcsr = await this.readMem32(DebugRegister.DHCSR);\n        let state: CoreState;\n\n        if (dhcsr & DhcsrMask.S_LOCKUP) state = CoreState.LOCKUP;\n        else if (dhcsr & DhcsrMask.S_SLEEP) state = CoreState.SLEEPING;\n        else if (dhcsr & DhcsrMask.S_HALT) state = CoreState.DEBUG;\n        else state = CoreState.RUNNING;\n\n        if (dhcsr & DhcsrMask.S_RESET_ST) {\n            // The core has been reset, check if an instruction has run\n            const newDhcsr = await this.readMem32(DebugRegister.DHCSR);\n            if (newDhcsr & DhcsrMask.S_RESET_ST && !(newDhcsr & DhcsrMask.S_RETIRE_ST)) {\n                return CoreState.RESET;\n            } else {\n                return state;\n            }\n        } else {\n            return state;\n        }\n    }\n\n    /**\n     * Whether the target is halted\n     * @returns Promise of halted state\n     */\n    public async isHalted(): Promise<boolean> {\n        const dhcsr = await this.readMem32(DebugRegister.DHCSR);\n        return !!(dhcsr & DhcsrMask.S_HALT);\n    }\n\n    /**\n     * Halt the target\n     * @param wait Wait until halted before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public async halt(wait: boolean = true, timeout: number = 0): Promise<void> {\n        const halted = await this.isHalted();\n\n        if (halted) {\n            return;\n        }\n\n        await this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN | DhcsrMask.C_HALT);\n\n        if (!wait) {\n            return;\n        }\n\n        return this.waitDelay(() => this.isHalted(), timeout);\n    }\n\n    /**\n     * Resume a target\n     * @param wait Wait until resumed before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public async resume(wait: boolean = true, timeout: number = 0) {\n        const halted = await this.isHalted();\n\n        if (!halted) {\n            return;\n        }\n\n        await this.writeMem32(DebugRegister.DFSR, DfsrMask.DWTTRAP | DfsrMask.BKPT | DfsrMask.HALTED);\n        await this.enableDebug();\n\n        if (!wait) {\n            return;\n        }\n\n        return this.waitDelay(async () => {\n            const result = await this.isHalted();\n            return !result;\n        }, timeout);\n    }\n\n    /**\n     * Read from a core register\n     * @param register The register to read\n     * @returns Promise of value\n     */\n    public async readCoreRegister(register: CoreRegister): Promise<number> {\n        const results = await this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRSR, register),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ]);\n\n        const dhcsr = results[0];\n        if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n            throw new Error('Register not ready');\n        }\n\n        return this.readMem32(DebugRegister.DCRDR);\n    }\n\n    /**\n     * Read an array of core registers\n     * @param registers The registers to read\n     * @returns Promise of register values in an array\n     */\n    public async readCoreRegisters(registers: CoreRegister[]): Promise<number[]> {\n        const results: number[] = [];\n\n        for (const register of registers) {\n            const result = await this.readCoreRegister(register);\n            results.push(result);\n        }\n\n        return results;\n    }\n\n    /**\n     * Write to a core register\n     * @param register The register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public async writeCoreRegister(register: CoreRegister, value: number): Promise<void> {\n        const results = await this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRDR, value),\n            this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ]);\n\n        const dhcsr = results[0];\n        if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n            throw new Error('Register not ready');\n        }\n    }\n\n    /**\n     * Exucute code at a specified memory address\n     * @param address The address to put the code\n     * @param code The code to use\n     * @param stackPointer The stack pointer to use\n     * @param programCounter The program counter to use\n     * @param linkRegister The link register to use (defaults to address + 1)\n     * @param registers Values to add to the general purpose registers, R0, R1, R2, etc.\n     */\n    public async execute(address: number, code: Uint32Array, stackPointer: number, programCounter: number, linkRegister: number = address + 1, ...registers: number[]): Promise<void> {\n        // Ensure a breakpoint exists at the end of the code\n        if (code[code.length - 1] !== BKPT_INSTRUCTION) {\n            const newCode = new Uint32Array(code.length + 1);\n            newCode.set(code);\n            newCode.set([BKPT_INSTRUCTION], code.length - 1);\n            code = newCode;\n        }\n\n        // Create sequence of core register writes\n        const sequence = [\n            this.writeCoreRegisterCommand(CoreRegister.SP, stackPointer),\n            this.writeCoreRegisterCommand(CoreRegister.PC, programCounter),\n            this.writeCoreRegisterCommand(CoreRegister.LR, linkRegister)\n        ];\n\n        // Add in register values R0, R1, R2, etc.\n        for (let i = 0; i < Math.min(registers.length, GENERAL_REGISTER_COUNT); i++) {\n            sequence.push(this.writeCoreRegisterCommand(i, registers[i]));\n        }\n\n        // Add xPSR.\n        sequence.push(this.writeCoreRegisterCommand(CoreRegister.PSR, 0x01000000));\n\n        await this.halt(); // Halt the target\n        await this.transferSequence(sequence); // Write the registers\n        await this.writeBlock(address, code); // Write the code to the address\n        await this.resume(false); // Resume the target, without waiting\n        await this.waitDelay(() => this.isHalted(), EXECUTE_TIMEOUT); // Wait for the target to halt on the breakpoint\n    }\n\n    /**\n     * soft reset the target\n     * @param None\n     * @returns Promise\n     */\n    public async softReset(): Promise<void> {\n        await this.writeMem32(DebugRegister.DEMCR, 0);\n        return this.writeMem32(NvicRegister.AIRCR, AircrMask.VECTKEY | AircrMask.SYSRESETREQ);\n    }\n\n    /**\n     * set the target to reset state\n     * @param hardwareReset use hardware reset pin or software reset\n     * @returns Promise\n     */\n    public async setTargetResetState(hardwareReset: boolean = true): Promise<void> {\n        await this.writeMem32(DebugRegister.DEMCR, DemcrMask.CORERESET);\n\n        if (hardwareReset === true) {\n            await this.reset();\n        } else {\n            const value = await this.readMem32(NvicRegister.AIRCR);\n            await this.writeMem32(NvicRegister.AIRCR, AircrMask.VECTKEY | value | AircrMask.SYSRESETREQ);\n        }\n\n        await this.writeMem32(DebugRegister.DEMCR, 0);\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { platform } from 'os';\nimport type { HID as nodeHID, Device } from 'node-hid';\nimport { Transport } from './';\n\n/**\n * HID Transport class\n */\nexport class HID implements Transport {\n\n    private os: string = platform();\n    private path: string;\n    private device?: nodeHID;\n    public readonly packetSize = 64;\n\n    /**\n     * HID constructor\n     * @param path Path to HID device to use\n     */\n    constructor(deviceOrPath: Device | string) {\n        const isDevice = (source: Device | string): source is Device => {\n            return (source as Device).path !== undefined;\n        };\n\n        this.path = isDevice(deviceOrPath) ? deviceOrPath.path! : deviceOrPath;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        if (!this.path.length) {\n            throw new Error('No path specified');\n        }\n\n        const hid = require('node-hid');\n        this.device = new hid.HID(this.path);\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        if (this.device) {\n            this.device.close();\n        }\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (!this.device) {\n            throw new Error('No device opened');\n        }\n\n        const array = await new Promise<number[]>((resolve, reject) => {\n            this.device!.read((error: string, data: number[]) => {\n                if (error) {\n                    return reject(new Error(error));\n                } else {\n                    resolve(data);\n                }\n            });\n        });\n\n        const buffer = new Uint8Array(array).buffer;\n        return new DataView(buffer);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (!this.device) {\n            throw new Error('No device opened');\n        }\n\n        const isView = (source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView => {\n            return (source as ArrayBufferView).buffer !== undefined;\n        };\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const array = Array.prototype.slice.call(new Uint8Array(arrayBuffer));\n\n        // Pad to packet size\n        while (array.length < this.packetSize) array.push(0);\n\n        // Windows requires the prepend of an extra byte\n        // https://github.com/node-hid/node-hid/blob/master/README.md#prepend-byte-to-hid_write\n        if (this.os === 'win32') {\n            array.unshift(0);  // prepend throwaway byte\n        }\n\n        const bytesWritten = this.device.write(array);\n        if (bytesWritten !== array.length) {\n            throw new Error('Incorrect bytecount written');\n        }\n    }\n}\n","/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 CoderPuppy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\nvar _endianness;\nexport function endianness() {\n  if (typeof _endianness === 'undefined') {\n    var a = new ArrayBuffer(2);\n    var b = new Uint8Array(a);\n    var c = new Uint16Array(a);\n    b[0] = 1;\n    b[1] = 2;\n    if (c[0] === 258) {\n      _endianness = 'BE';\n    } else if (c[0] === 513){\n      _endianness = 'LE';\n    } else {\n      throw new Error('unable to figure out endianess');\n    }\n  }\n  return _endianness;\n}\n\nexport function hostname() {\n  if (typeof global.location !== 'undefined') {\n    return global.location.hostname\n  } else return '';\n}\n\nexport function loadavg() {\n  return [];\n}\n\nexport function uptime() {\n  return 0;\n}\n\nexport function freemem() {\n  return Number.MAX_VALUE;\n}\n\nexport function totalmem() {\n  return Number.MAX_VALUE;\n}\n\nexport function cpus() {\n  return [];\n}\n\nexport function type() {\n  return 'Browser';\n}\n\nexport function release () {\n  if (typeof global.navigator !== 'undefined') {\n    return global.navigator.appVersion;\n  }\n  return '';\n}\n\nexport function networkInterfaces(){}\nexport function getNetworkInterfaces(){}\n\nexport function arch() {\n  return 'javascript';\n}\n\nexport function platform() {\n  return 'browser';\n}\n\nexport function tmpDir() {\n  return '/tmp';\n}\nexport var tmpdir = tmpDir;\n\nexport var EOL = '\\n';\nexport default {\n  EOL: EOL,\n  tmpdir: tmpdir,\n  tmpDir: tmpDir,\n  networkInterfaces:networkInterfaces,\n  getNetworkInterfaces: getNetworkInterfaces,\n  release: release,\n  type: type,\n  cpus: cpus,\n  totalmem: totalmem,\n  freemem: freemem,\n  uptime: uptime,\n  loadavg: loadavg,\n  hostname: hostname,\n  endianness: endianness,\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport type { Device, InEndpoint, OutEndpoint} from 'usb';\nimport { Transport } from './';\n\n/**\n * @hidden\n */\nconst LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5);\n/**\n * @hidden\n */\nconst LIBUSB_RECIPIENT_INTERFACE = 0x01;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_OUT = 0x00;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_IN = 0x80;\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * USB Transport class\n */\nexport class USB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: InEndpoint;\n    private endpointOut?: OutEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * USB constructor\n     * @param device USB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: Device, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private bufferToDataView(buffer: Buffer): DataView {\n        const arrayBuffer = new Uint8Array(buffer).buffer;\n        return new DataView(arrayBuffer);\n    }\n\n    private isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n        return (source as ArrayBufferView).buffer !== undefined;\n    }\n\n    private bufferSourceToBuffer(bufferSource: ArrayBuffer | ArrayBufferView): Buffer {\n        const arrayBuffer = this.isView(bufferSource) ? bufferSource.buffer : bufferSource;\n        return Buffer.from(arrayBuffer);\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        const arrayBuffer = this.isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        this.device.open();\n\n        await new Promise((resolve, reject) => {\n            this.device.setConfiguration(this.configuration, error => {\n                if (error) {\n                    reject(new Error(error));\n                } else {\n                    resolve();\n                }\n            });\n        });\n\n        const interfaces = this.device.interfaces.filter(iface => {\n            return iface.descriptor.bInterfaceClass === this.interfaceClass;\n        });\n\n        if (!interfaces.length) {\n            throw new Error('No valid interfaces found.');\n        }\n\n        // Prefer interface with endpoints\n        let selectedInterface = interfaces.find(iface => iface.endpoints.length > 0);\n\n        // Otherwise use the first\n        if (!selectedInterface) {\n            selectedInterface = interfaces[0];\n        }\n\n        this.interfaceNumber = selectedInterface.interfaceNumber;\n\n        // If we always want to use control transfer, don't find/set endpoints and claim interface\n        if (!this.alwaysControlTransfer) {\n            const endpoints = selectedInterface.endpoints;\n\n            this.endpointIn = undefined;\n            this.endpointOut = undefined;\n\n            for (const endpoint of endpoints) {\n                if (endpoint.direction === 'in') this.endpointIn = (endpoint as InEndpoint);\n                else this.endpointOut = (endpoint as OutEndpoint);\n            }\n\n            // If endpoints are found, claim the interface\n            if (this.endpointIn || this.endpointOut) {\n\n                // If the interface can't be claimed, use control transfer\n                try {\n                    selectedInterface.claim();\n                } catch (_e) {\n                    this.endpointIn = undefined;\n                    this.endpointOut = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public async close(): Promise<void> {\n        this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const result = await new Promise<Buffer>((resolve, reject) => {\n            // Use endpoint if it exists\n            if (this.endpointIn) {\n                this.endpointIn.transfer(this.packetSize, (exception, buffer) => {\n                    if (exception) {\n                        reject(exception);\n                    } else {\n                        resolve(buffer);\n                    }\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                GET_REPORT,\n                IN_REPORT,\n                this.interfaceNumber!,\n                this.packetSize,\n                (exception, buffer) => {\n                    if (exception) {\n                        reject(exception);\n                    } else if (!buffer) {\n                        reject(new Error('No buffer read'));\n                    } else {\n                        resolve(buffer);\n                    }\n                }\n            );\n        });\n\n        return this.bufferToDataView(result);\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const extended = this.extendBuffer(data, this.packetSize);\n        const buffer = this.bufferSourceToBuffer(extended);\n\n        await new Promise((resolve, reject) => {\n            // Use endpoint if it exists\n            if (this.endpointOut) {\n                this.endpointOut.transfer(buffer, exception => {\n                    if (exception) {\n                        return reject(exception);\n                    } else {\n                        resolve();\n                    }\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                SET_REPORT,\n                OUT_REPORT,\n                this.interfaceNumber!,\n                buffer,\n                exception => {\n                    if (exception) {\n                        return reject(exception);\n                    } else {\n                        resolve();\n                    }\n                }\n            );\n        });\n    }\n}\n","/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from './';\n\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * WebUSB Transport class\n * https://wicg.github.io/webusb/\n */\nexport class WebUSB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: USBEndpoint;\n    private endpointOut?: USBEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * WebUSB constructor\n     * @param device WebUSB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: USBDevice, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public async open(): Promise<void> {\n        await this.device.open();\n        await this.device.selectConfiguration(this.configuration);\n\n        const interfaces = this.device.configuration!.interfaces.filter(iface => {\n            return iface.alternates[0].interfaceClass === this.interfaceClass;\n        });\n\n        if (!interfaces.length) {\n            throw new Error('No valid interfaces found.');\n        }\n\n        // Prefer interface with endpoints\n        let selectedInterface = interfaces.find(iface => iface.alternates[0].endpoints.length > 0);\n\n        // Otherwise use the first\n        if (!selectedInterface) {\n            selectedInterface = interfaces[0];\n        }\n\n        this.interfaceNumber = selectedInterface.interfaceNumber;\n\n        // If we always want to use control transfer, don't find/set endpoints and claim interface\n        if (!this.alwaysControlTransfer) {\n            const endpoints = selectedInterface.alternates[0].endpoints;\n\n            this.endpointIn = undefined;\n            this.endpointOut = undefined;\n\n            for (const endpoint of endpoints) {\n                if (endpoint.direction === 'in') this.endpointIn = endpoint;\n                else this.endpointOut = endpoint;\n            }\n        }\n\n        return this.device.claimInterface(this.interfaceNumber);\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return this.device.close();\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public async read(): Promise<DataView> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        let result: USBInTransferResult;\n\n        if (this.endpointIn) {\n            // Use endpoint if it exists\n            result = await this.device.transferIn(\n                this.endpointIn.endpointNumber,\n                this.packetSize\n            );\n        } else {\n            // Fallback to using control transfer\n            result = await this.device.controlTransferIn(\n                {\n                    requestType: 'class',\n                    recipient: 'interface',\n                    request: GET_REPORT,\n                    value: IN_REPORT,\n                    index: this.interfaceNumber\n                },\n                this.packetSize\n            );\n        }\n\n        return result.data!;\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public async write(data: BufferSource): Promise<void> {\n        if (this.interfaceNumber === undefined) {\n            throw new Error('No device opened');\n        }\n\n        const buffer = this.extendBuffer(data, this.packetSize);\n\n        if (this.endpointOut) {\n            // Use endpoint if it exists\n            await this.device.transferOut(\n                this.endpointOut.endpointNumber,\n                buffer\n            );\n        } else {\n            // Fallback to using control transfer\n            await this.device.controlTransferOut(\n                {\n                    requestType: 'class',\n                    recipient: 'interface',\n                    request: SET_REPORT,\n                    value: OUT_REPORT,\n                    index: this.interfaceNumber\n                },\n                buffer\n            );\n        }\n    }\n}\n"],"names":["EventHandlers","EventEmitter","init","call","this","$getMaxListeners","that","undefined","_maxListeners","defaultMaxListeners","emitNone","handler","isFn","self","len","length","listeners","arrayClone","i","emitOne","arg1","emitTwo","arg2","emitThree","arg3","emitMany","args","apply","_addListener","target","type","listener","prepend","m","events","existing","e","TypeError","_events","newListener","emit","_eventsCount","unshift","push","warned","w","Error","name","emitter","count","console","warn","log","_onceWrap","fired","g","removeListener","arguments","listenerCount","evlistener","arr","copy","Array","prototype","Object","create","usingDomains","domain","active","getPrototypeOf","setMaxListeners","n","isNaN","getMaxListeners","er","doError","error","err","context","domainEmitter","domainThrown","addListener","on","prependListener","once","prependOnceListener","list","position","originalListener","index","k","pop","spliceOne","removeAllListeners","key","keys","ret","unwrapListeners","eventNames","Reflect","ownKeys","FPBCtrlMask","Mutex","locked","Promise","resolve","setTimeout","_a","transport","mode","clockFrequency","_super","_this","blockSize","packetSize","operationSpace","operationCount","Math","floor","__extends","CmsisDAP","prefix","data","Uint8Array","arrayBuffer","buffer","result","byteLength","set","protocol","sequence","swjSequence","Uint16Array","command","array","bufferSourceToUint8Array","sendMutex","lock","write","read","response","getUint8","unlock","abortMask","send","request","length_1","getUint16","getUint32","ascii","slice","String","fromCharCode","clearAbort","error_1","bitLength","error_2","idleCycles","waitRetry","matchRetry","view","DataView","setUint8","setUint16","error_3","connected","open","Uint32Array","close","error_4","configureTransfer","selectProtocol","error_5","error_6","disconnect","connect","error_7","portOrOps","register","value","operations","port","forEach","operation","offset","setUint32","length_2","error_8","countOrValues","dataSize","countOrValue","error_9","PARTIAL_CHAR_TEST","DOUBLE_BYTE_REPLACE","TextDecoder","input","numberArray","fromCodePoint","partialChar","match","replace","decoderReplacer","encoded","codePoint","codePointAt","leadingOnes","clz32","endPos","stringLen","decoder","event","DAPLink","EVENT_SERIAL_DATA","serialListeners","bufferString","charCode","charCodeAt","pageSize","end","min","page","EVENT_PROGRESS","writeBuffer","source","isView","streamType","isBufferBinary","baudrate","arrayData","split","map","serialData","dataLength","serialDelay","autoConnect","serialPolling","connectedState","serialRead","decode","transportOrDap","proxy","ADI","fn","timeout","timer","running","arrays","arrays_1","_i","j","selectedAddress","address","writeDPCommand","concat","cswValue","writeAPCommand","readAPCommand","merged","results","splice","transfer","concatTypedArray","mask","readDP","transferSequence","waitDelay","reset","readDPCommand","readMem16Command","writeMem16Command","readMem32Command","writeMem32Command","remainder","chunkSize","transferBlock","values","chunk","CortexM","writeMem32","readMem32","dhcsr","state","newDhcsr","wait","isHalted","enableDebug","registers","registers_1","readCoreRegister","code","stackPointer","programCounter","linkRegister","newCode","writeCoreRegisterCommand","halt","writeBlock","resume","hardwareReset","deviceOrPath","path","HID","hid","require","device","reject","os","interfaceClass","configuration","alwaysControlTransfer","USB","bufferSource","Buffer","from","setConfiguration","interfaces","filter","iface","descriptor","bInterfaceClass","selectedInterface","find","endpoints","interfaceNumber","endpointIn","endpointOut","endpoints_1","endpoint","direction","claim","_e","exception","controlTransfer","LIBUSB_ENDPOINT_IN","bufferToDataView","extended","extendBuffer","bufferSourceToBuffer","LIBUSB_ENDPOINT_OUT","WebUSB","selectConfiguration","alternates","claimInterface","transferIn","endpointNumber","controlTransferIn","requestType","recipient","transferOut","controlTransferOut"],"mappings":"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"}